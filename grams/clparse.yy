
%code requires {
    namespace cl {
        class Scanner;  // Generated by reflex with namespace=cl lexer=Lexer lex=yylex
    }
    
    #include "structs.hpp"
    
    #include <string>
    #include <vector>
    

}

%code provides {
    
}

%code {
    #undef yylex
    #define yylex lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()

}
%{
    #include "cllang.hpp"
    #include "back.hpp"
    #include "structs.hpp"


%}
%skeleton "lalr1.cc" // -*- C++ -*-
%require "3.8.2"
%language "c++"
%define api.value.type variant
%define api.token.prefix {TOK_}
%parse-param { cl::Scanner& lexer } { std::vector<op_t> * res }
%define api.token.constructor
%define api.namespace {cl}
%token SEP IMP EOS VAR CAL LBAR RBAR
%token <std::string> MATHSTATE
%token <std::string> CMDPART
%nterm <std::vector<op_t>> cmd
%nterm <std::vector<op_t>> inp
%nterm <std::vector<op_t>> arr

%glr-parser
%define parse.error detailed


%start inp
%%
inp: cmd { $$ = $1; *res = $$; } ;
cmd: CMDPART { std::cout << "matched?\n"; $$ = std::vector<op_t>({$1});  }
    | cmd CMDPART { $$ = $1; $$.push_back($2); }
    | cmd MATHSTATE { $$ = $1; $$.push_back(fromString($2)); }
    | cmd LBAR arr RBAR { $$ = $1; for (auto a : $3) $$.push_back(a); }
    ;

arr: CMDPART { $$ = std::vector<op_t>({$1}); }
    | arr SEP CMDPART { $$ = $1; $$.push_back($3); }
    ;

%%

void cl::parser::error(const std::string& msg)
{
  std::cerr << msg << std::endl;
}


/*
int yyerror(const char *s)
{
	return fprintf(stderr, "%s\n", s);
}
*/


