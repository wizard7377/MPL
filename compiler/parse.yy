
%code requires {
    namespace yy {
        class Scanner;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
    }
    
    #include "structs.hpp"
    
    #include <string>
    #include <vector>
    

}

%code provides {
    
}

%code {
    #undef yylex
    #define yylex lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()

}
%{
    #include "lang.hpp"


%}
%skeleton "lalr1.cc" // -*- C++ -*-
%require "3.8.2"
%language "c++"
%define api.value.type variant
%define api.token.prefix {TOK_}
%parse-param { yy::Scanner& lexer } { resultClass * res }
%define api.token.constructor
%token SEP IMP EOS VAR
%token <std::string> MATHTOK
%nterm <std::vector<mtoken>> state
%nterm <std::vector<std::vector<mtoken>>> stategroup
%nterm <ruleForm> hypo
%nterm <std::vector<ruleForm>> hgroup
%nterm <std::vector<ruleForm>> ffile
%glr-parser
%define parse.error detailed


%start ffile
%%

ffile: hgroup YYEOF { $$ = $1; *res = $$; } ;
hgroup: hypo { $$ = std::vector<ruleForm>({$1}); }
    | hgroup hypo { $$ = $1; $$.push_back($2); }
    ;
hypo: stategroup EOS { 
		$$.preState = statel();
		$$.proveState = $1;
	}
    | stategroup IMP stategroup EOS {
		$$.preState = $1;
		$$.proveState = $3;
	}	
    ;
stategroup: state { $$ = statel({$1}); }
    | stategroup SEP state { $$ = $1; $$.push_back($3); }
    ;
state: MATHTOK { $$.emplace_back(); $$[0].txt = $1; $$[0].tType = T_LIT; }
    | VAR MATHTOK { $$.emplace_back(); $$[0].txt = $2; $$[0].tType = T_VAR; }
    | state state { $$ = $1; for (auto a : $2) $$.push_back(a); }	
    ;
%%

void yy::parser::error(const std::string& msg)
{
  std::cerr << msg << std::endl;
}


/*
int yyerror(const char *s)
{
	return fprintf(stderr, "%s\n", s);
}
*/


